from collections.abc import Callable, Mapping, Sequence
from types import TracebackType
from typing import Any, Optional, Protocol, Tuple, TypeVar, Union, overload

from ..log import Identified
from ..pool import Pool
from ..sql.compiler import Compiled
from ..sql.ddl import DDLElement
from ..sql.elements import ClauseElement
from ..sql.functions import FunctionElement
from ..sql.schema import DefaultGenerator
from .cursor import CursorResult
from .interfaces import Connectable, Dialect, ExceptionContext
from .util import TransactionalContext

_T = TypeVar("_T")

DBAPITypeCode = Union[Any, None]
# Strictly speaking, this should be a Sequence, but the type system does
# not support fixed-length sequences.
DBAPIColumnDescription = Tuple[str, DBAPITypeCode, Optional[int], Optional[int], Optional[int], Optional[int], Optional[bool]]

# FIXME: move to _typeshed.dbapi
class DBAPIConnection(Protocol):
    def close(self) -> Any: ...
    def commit(self) -> Any: ...
    # optional:
    # def rollback(self) -> Any: ...
    def cursor(self) -> DBAPICursor: ...

class DBAPICursor(Protocol):
    @property
    def description(self) -> Sequence[DBAPIColumnDescription] | None: ...
    @property
    def rowcount(self) -> int: ...
    # optional:
    # def callproc(self, __procname: str, __parameters: Sequence[Any] = ...) -> Any: ...
    def close(self) -> None: ...
    def execute(self, __operation: str, __parameters: Sequence[Any] | Mapping[str, Any] = ...) -> Any: ...
    def executemany(self, __operation: str, __seq_of_parameters: Sequence[Sequence[Any]]) -> Any: ...
    def fetchone(self) -> Sequence[Any] | None: ...
    def fetchmany(self, __size: int = ...) -> Sequence[Sequence[Any]]: ...
    def fetchall(self) -> Sequence[Sequence[Any]]: ...
    # optional:
    # def nextset(self) -> None | Literal[True]: ...
    arraysize: int
    def setinputsize(self, __sizes: Sequence[DBAPITypeCode | int | None]) -> Any: ...
    def setoutputsize(self, __size: int, __column: int = ...) -> Any: ...

class Connection(Connectable):
    engine: Engine
    dialect: Dialect
    should_close_with_result: bool
    def __init__(
        self,
        engine: Engine,
        connection: DBAPIConnection | None = ...,
        close_with_result: bool = ...,
        _branch_from: Any | None = ...,
        _execution_options: Any | None = ...,
        _dispatch: Any | None = ...,
        _has_events: Any | None = ...,
        _allow_revalidate: bool = ...,
    ) -> None: ...
    def schema_for_object(self, obj: Any) -> str: ...
    def __enter__(self) -> Connection: ...
    def __exit__(self, type_: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None) -> None: ...
    def execution_options(self, **opt: Any) -> Any: ...
    def get_execution_options(self) -> Any: ...
    @property
    def closed(self) -> bool: ...
    @property
    def invalidated(self) -> bool: ...
    @property
    def connection(self) -> DBAPIConnection: ...
    def get_isolation_level(self) -> Any: ...
    @property
    def default_isolation_level(self) -> Any: ...
    @property
    def info(self) -> Any: ...
    def connect(self, close_with_result: bool = ...) -> Any: ...
    def invalidate(self, exception: Exception | None) -> None: ...
    def detach(self) -> None: ...
    def begin(self) -> Transaction | None: ...
    def begin_nested(self) -> Transaction | None: ...
    def begin_twophase(self, xid: Any | None = ...) -> TwoPhaseTransaction: ...
    def recover_twophase(self) -> Any: ...
    def rollback_prepared(self, xid: Any, recover: bool = ...) -> None: ...
    def commit_prepared(self, xid: Any, recover: bool = ...) -> None: ...
    def in_transaction(self) -> bool: ...
    def in_nested_transaction(self) -> bool: ...
    def get_transaction(self) -> Transaction | None: ...
    def get_nested_transaction(self) -> Transaction | None: ...
    def close(self) -> None: ...
    @overload
    def scalar(
        self,
        object_: ClauseElement | FunctionElement | DDLElement | DefaultGenerator | Compiled,
        *multiparams: Mapping[str, Any],
        **params: Any,
    ) -> Any: ...
    @overload
    def scalar(
        self,
        object_: str,
        *multiparams: Any | Tuple[Any, ...] | Mapping[str, Any],
        **params: Any,
    ) -> Any: ...
    @overload  # type: ignore
    def execute(
        self,
        statement: ClauseElement | FunctionElement | DDLElement | DefaultGenerator | Compiled,
        *multiparams: Mapping[str, Any],
        **params: Any,
    ) -> CursorResult: ...
    @overload
    def execute(
        self,
        statement: str,
        *multiparams: Any | Tuple[Any, ...] | Mapping[str, Any],
        **params: Any,
    ) -> CursorResult: ...
    def exec_driver_sql(self, statement: str, parameters: Any | None = ..., execution_options: Any | None = ...) -> Any: ...
    # callable_ is passed a Connection as first parameter, and args and kwargs.
    def transaction(self, callable_: Callable[..., _T], *args: Any, **kwargs: Any) -> _T | None: ...
    # callable_ is passed a Connection as first parameter, and args and kwargs.
    def run_callable(self, callable_: Callable[..., _T], *args: Any, **kwargs: Any) -> _T: ...

class ExceptionContextImpl(ExceptionContext):
    def __init__(
        self,
        exception: Any,
        sqlalchemy_exception: Any,
        engine: Any,
        connection: Any,
        cursor: Any,
        statement: Any,
        parameters: Any,
        context: Any,
        is_disconnect: Any,
        invalidate_pool_on_disconnect: Any,
    ) -> None: ...

# Abstract base class, non-instantiable
class Transaction(TransactionalContext):
    def __init__(self, connection: Connection) -> None: ...
    def is_valid(self) -> bool: ...
    def close(self) -> None: ...
    def rollback(self) -> None: ...
    def commit(self) -> None: ...
    # The following field are technically not defined on Transaction, but on
    # all sub-classes.
    connection: Connection
    def is_active(self) -> bool: ...

class MarkerTransaction(Transaction): ...
class RootTransaction(Transaction): ...
class NestedTransaction(Transaction): ...

class TwoPhaseTransaction(RootTransaction):
    def __init__(self, connection: Connection, xid: Any) -> None: ...
    def prepare(self) -> None: ...

class Engine(Connectable, Identified):
    pool: Pool
    url: str
    dialect: Dialect
    echo: bool | None
    hide_parameters: bool

    class _trans_ctx:
        def __enter__(self) -> Connection: ...
        def __exit__(self, type_: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None) -> None: ...

    def __init__(
        self,
        pool: Pool,
        dialect: Dialect,
        url: str,
        logging_name: str | None = ...,
        echo: bool | None = ...,
        proxy: Any | None = ...,
        execution_options: Mapping[str, Any] | None = ...,
        hide_parameters: bool = ...,
    ) -> None: ...
    @property
    def engine(self) -> Engine: ...
    def clear_compiled_cache(self) -> None: ...
    def update_execution_options(self, **opt: Any) -> None: ...
    def execution_options(self, **opt: Any) -> Any: ...
    def get_execution_options(self) -> Any: ...
    @property
    def name(self) -> str: ...
    @property
    def driver(self) -> Any: ...
    def dispose(self) -> None: ...
    def begin(self, close_with_result: bool = ...) -> _trans_ctx: ...
    # callable_ is passed a Connection as first parameter, and args and kwargs.
    def transaction(self, callable_: Callable[..., _T], *args: Any, **kwargs: Any) -> _T: ...
    # callable_ is passed a Connection as first parameter, and args and kwargs.
    def run_callable(self, callable_: Callable[..., _T], *args: Any, **kwargs: Any) -> _T: ...
    def execute(  # type: ignore
        self,
        statement: str | ClauseElement | FunctionElement | DDLElement | DefaultGenerator | Compiled,
        *multiparams: Mapping[str, Any],
        **params: Any,
    ) -> CursorResult: ...
    def scalar(  # type: ignore
        self,
        statement: str | ClauseElement | FunctionElement | DDLElement | DefaultGenerator | Compiled,
        *multiparams: Mapping[str, Any],
        **params: Any,
    ) -> Any: ...
    def connect(self, close_with_result: bool = ...) -> Connection: ...
    def table_names(self, schema: Any | None = ..., connection: Connection | None = ...) -> Any: ...
    def has_table(self, table_name: str, schema: Any | None = ...) -> bool: ...
    def raw_connection(self, _connection: Connection | None = ...) -> DBAPIConnection: ...

class OptionEngineMixin:
    url: str
    dialect: Dialect
    logging_name: str | None
    echo: bool
    hide_parameters: bool
    dispatch: Any
    pool: Any
    def __init__(self, proxied: Any, execution_options: Any) -> None: ...

class OptionEngine(OptionEngineMixin, Engine): ...  # type: ignore

def __getattr__(__name: str) -> Any: ...  # incomplete
